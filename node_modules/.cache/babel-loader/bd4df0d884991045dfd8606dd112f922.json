{"ast":null,"code":"import { fromEntries } from \"./chunk-YTQ3XZ3T.mjs\";\nimport { getLastItem } from \"./chunk-YTAYUX3P.mjs\";\nimport { isNumber, isObject } from \"./chunk-Y5FGD7DM.mjs\";\n\n// src/breakpoint.ts\nfunction analyzeCSSValue(value) {\n  const num = parseFloat(value.toString());\n  const unit = value.toString().replace(String(num), \"\");\n  return {\n    unitless: !unit,\n    value: num,\n    unit\n  };\n}\nfunction px(value) {\n  if (value == null) return value;\n  const {\n    unitless\n  } = analyzeCSSValue(value);\n  return unitless || isNumber(value) ? `${value}px` : value;\n}\nvar sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;\nvar sortBps = breakpoints => fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));\nfunction normalize(breakpoints) {\n  const sorted = sortBps(breakpoints);\n  return Object.assign(Object.values(sorted), sorted);\n}\nfunction keys(breakpoints) {\n  const value = Object.keys(sortBps(breakpoints));\n  return new Set(value);\n}\nfunction subtract(value) {\n  var _a;\n  if (!value) return value;\n  value = (_a = px(value)) != null ? _a : value;\n  const factor = value.endsWith(\"px\") ? -0.02 : -0.01;\n  return isNumber(value) ? `${value + factor}` : value.replace(/(\\d+\\.?\\d*)/u, m => `${parseFloat(m) + factor}`);\n}\nfunction toMediaQueryString(min, max) {\n  const query = [\"@media screen\"];\n  if (min) query.push(\"and\", `(min-width: ${px(min)})`);\n  if (max) query.push(\"and\", `(max-width: ${px(max)})`);\n  return query.join(\" \");\n}\nfunction analyzeBreakpoints(breakpoints) {\n  var _a;\n  if (!breakpoints) return null;\n  breakpoints.base = (_a = breakpoints.base) != null ? _a : \"0px\";\n  const normalized = normalize(breakpoints);\n  const queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {\n    var _a2;\n    let [, maxW] = (_a2 = entry[index + 1]) != null ? _a2 : [];\n    maxW = parseFloat(maxW) > 0 ? subtract(maxW) : void 0;\n    return {\n      _minW: subtract(minW),\n      breakpoint,\n      minW,\n      maxW,\n      maxWQuery: toMediaQueryString(null, maxW),\n      minWQuery: toMediaQueryString(minW),\n      minMaxQuery: toMediaQueryString(minW, maxW)\n    };\n  });\n  const _keys = keys(breakpoints);\n  const _keysArr = Array.from(_keys.values());\n  return {\n    keys: _keys,\n    normalized,\n    isResponsive(test) {\n      const keys2 = Object.keys(test);\n      return keys2.length > 0 && keys2.every(key => _keys.has(key));\n    },\n    asObject: sortBps(breakpoints),\n    asArray: normalize(breakpoints),\n    details: queries,\n    media: [null, ...normalized.map(minW => toMediaQueryString(minW)).slice(1)],\n    toArrayValue(test) {\n      if (!isObject(test)) {\n        throw new Error(\"toArrayValue: value must be an object\");\n      }\n      const result = _keysArr.map(bp => {\n        var _a2;\n        return (_a2 = test[bp]) != null ? _a2 : null;\n      });\n      while (getLastItem(result) === null) {\n        result.pop();\n      }\n      return result;\n    },\n    toObjectValue(test) {\n      if (!Array.isArray(test)) {\n        throw new Error(\"toObjectValue: value must be an array\");\n      }\n      return test.reduce((acc, value, index) => {\n        const key = _keysArr[index];\n        if (key != null && value != null) acc[key] = value;\n        return acc;\n      }, {});\n    }\n  };\n}\nexport { px, toMediaQueryString, analyzeBreakpoints };","map":null,"metadata":{},"sourceType":"module"}